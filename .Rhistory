y_uni = c(0,1,10)
t = 3
# calculating number of states
num_state <- length(y_uni)
# calculating number of unique state possibilities
num_possibs <- num_state^t - num_state
# initializing matrix for holding unique state possibilities
# each column is a time period
# no constant-state solutions will be included
possibs <- matrix(0,num_possibs,t)
# initializing matrix for holding unique state possibilities
# each column is a time period
# constant-state solutions will be included
possibs_const <- matrix(0,num_possib+num_state,t)
# initializing matrix for holding unique state possibilities
# each column is a time period
# constant-state solutions will be included
possibs_const <- matrix(0,num_possibs+num_state,t)
for (i1 in 1:t){
# length of repeating number pattern
len <- (num_possibs + num_state)/(num_state^i1)
# number of repititions of the pattern
rep <- num_state^(i1-1)
# initializing counter
count <- 1
for (i2 in 1:rep){
for (i3 in 1:num_state){
# copying unique index into correct values
possibs_const[seq(count,count+len-1,by=1),i1] <- y_uni(i3)
# indexing counter
count <- count + len
} # end inner most for loop
} # end middle for loop
} # end outer for loop
for (i1 in 1:t){
# length of repeating number pattern
len <- (num_possibs + num_state)/(num_state^i1)
# number of repititions of the pattern
rep <- num_state^(i1-1)
# initializing counter
count <- 1
for (i2 in 1:rep){
for (i3 in 1:num_state){
# copying unique index into correct values
possibs_const[seq(count,count+len-1,by=1),i1] <- y_uni[i3]
# indexing counter
count <- count + len
} # end inner most for loop
} # end middle for loop
} # end outer for loop
rowSums((possibs_const - rowMeans(possibs_const))^2)
which(rowSums((possibs_const - rowMeans(possibs_const))^2) %in% 0)
which(rowSums((possibs_const - rowMeans(possibs_const))^2) != 0)
possibs <- possibs_const[which(rowSums((possibs_const - rowMeans(possibs_const))^2) != 0),]
View(possibs)
